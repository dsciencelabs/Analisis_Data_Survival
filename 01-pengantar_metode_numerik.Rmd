
# Pengantar Metode Numerik

Metode Numerik diterapkan ketika solusi analitis tidak mungkin atau sulit ditemukan, terutama dalam situasi di mana terdapat unsur ketidakpastian atau kompleksitas yang tinggi. Metode ini digunakan untuk memecahkan berbagai masalah, seperti:

* **Pencarian Akar Persamaan:** mencari akar (solusi) dari persamaan non-linear, yang mungkin sulit atau bahkan tidak mungkin diselesaikan secara analitis.
* **Interpolasi dan Pendekatan Fungsi:** membangun fungsi pendekatan yang sesuai untuk set data, yang berguna dalam analisis dan prediksi.
* **Integrasi Numerik:** menghitung integral dari fungsi yang kompleks atau tidak memiliki bentuk integral tertutup.
* **Pemecahan Sistem Persamaan Linear:** menemukan solusi sistem persamaan linear, yang mungkin memiliki banyak variabel dan persamaan.
* **Optimisasi Numerik:** mencari nilai maksimum atau minimum dari fungsi yang kompleks dengan cara mengiterasi melalui berbagai kemungkinan solusi.
* **Pemodelan Numerik:** digunakan dalam simulasi numerik untuk memodelkan fenomena ilmiah atau teknik, seperti dinamika fluida, mekanika struktur, dan banyak lagi.


Pemahaman tentang Metode Numerik sangat penting dalam berbagai bidang, termasuk ilmu komputer, teknik, ilmu pengetahuan alam, ekonomi, dan masih banyak lagi. Keterampilan dalam mengaplikasikan metode numerik membantu dalam merancang algoritma yang efisien, mengatasi masalah yang kompleks, dan membuat prediksi yang lebih baik dalam dunia nyata.


## Metode vs Analitik Numerik 

Perbedaan antara metode numerik dan metode analitik menurut definisinya dapat dijelaskan sebagai berikut:

* **Metode Analitik** adalah pendekatan matematis untuk memecahkan masalah secara eksak atau analitis. Dalam metode ini, solusi ditemukan melalui manipulasi aljabar dan penerapan aturan matematika. Solusi analitis menghasilkan bentuk persamaan atau fungsi yang menggambarkan solusi secara tepat. Contoh dari metode analitik termasuk menghitung turunan, integral tertutup, dan menyelesaikan persamaan aljabar dengan cara mengisolasi variabel.
* **Metode Analitik** adalah pendekatan matematis untuk memecahkan masalah secara eksak atau analitis. Dalam metode ini, solusi ditemukan melalui manipulasi aljabar dan penerapan aturan matematika. Solusi analitis menghasilkan bentuk persamaan atau fungsi yang menggambarkan solusi secara tepat. Contoh dari metode analitik termasuk menghitung turunan, integral tertutup, dan menyelesaikan persamaan aljabar dengan cara mengisolasi variabel.

Adapun perberdaan metode numerik dan metode analitik berdasarkan kelebihan dan kekurangannya dapat diuraikan sebagai berikut:

* Solusi metode numerik selalu berbentuk angka, sedangkan solusi metode analitik dapat berbentuk fungsi matematik yang selanjutnya dapat dievaluasi untuk menghasilkan nilai dalam bentuk angka.
* Solusi dari metode numerik berupa hampiran, sedangkan metode analitik berupa solusi sejati. Kondisi ini berakibat pada nilai error metode analitik adalah 0, sedangkan metode numerik $\neq 0$.
* Metode analitik cocok untuk permasalahan dengan model terbatas dan sederhana, sedangkan metode numerik cocok dengan semua jenis permasalahan.

## Tahapan Metode Numerik

Tahapan dalam penerapan Metode Numerik melibatkan serangkaian langkah yang disusun secara sistematis untuk memecahkan masalah matematika secara numerik. Berikut adalah tahapan umum yang terlibat dalam Metode Numerik:

* **Perumusan Masalah:** Tentukan masalah matematika yang ingin Anda selesaikan secara numerik, misalnya, mencari akar persamaan, menghitung integral, atau menyelesaikan sistem persamaan linear.
* **Pemilihan Metode:** Pilih metode numerik yang sesuai untuk masalah yang Anda hadapi. Misalnya, jika Anda ingin mencari akar persamaan, Anda dapat menggunakan metode seperti metode bisection, metode Newton-Raphson, atau metode iteratif lainnya.
* **Pembuatan Algoritma:** Buat algoritma berdasarkan metode yang dipilih. Algoritma ini harus berisi langkah-langkah yang jelas dan terdefinisi untuk mencari solusi numerik.
* **Pemrograman:** Implementasikan algoritma dalam bahasa pemrograman, seperti R, Python, MATLAB, atau bahasa lainnya. Pemrograman melibatkan mengubah langkah-langkah algoritma menjadi kode yang dapat dieksekusi oleh komputer.
* **Inisialisasi:** Inisialisasi nilai awal yang diperlukan untuk memulai iterasi algoritma. Nilai inisialisasi ini dapat mempengaruhi konvergensi dan akurasi solusi.
* **Iterasi:** Jalankan algoritma secara berulang (iteratif) sesuai dengan langkah-langkah yang telah ditentukan. Setiap iterasi mengarahkan solusi lebih dekat ke solusi akhir yang diinginkan.
* **Konvergensi dan Kriteria Berhenti:** Tentukan kriteria berhenti iterasi. Misalnya, berhenti saat perbedaan antara solusi saat ini dan solusi sebelumnya cukup kecil, atau ketika jumlah iterasi mencapai batas tertentu.
* **Analisis Hasil:** Analisis hasil dari algoritma numerik. Evaluasi apakah solusi yang ditemukan sudah cukup akurat sesuai dengan kriteria yang ditentukan.
* **Presentasi dan Interpretasi:** Presentasikan solusi numerik secara grafis atau dalam bentuk yang mudah dimengerti. Jelaskan hasilnya dalam konteks masalah yang dipecahkan.
* **Validasi:** Validasi hasil dengan cara membandingkannya dengan solusi analitis (jika tersedia) atau dengan hasil lain yang diperoleh melalui metode numerik alternatif.
  * **Optimisasi dan Peningkatan:** Jika diperlukan, pertimbangkan untuk mengoptimasi algoritma atau mengganti metode numerik untuk meningkatkan akurasi atau efisiensi solusi.
  * **Penggunaan Kembali:** Terapkan kembali metode numerik dan algoritma yang telah diuji dan diimplementasikan untuk masalah serupa di masa depan.

Tahapan-tahapan ini membantu memastikan bahwa penerapan Metode Numerik dilakukan secara sistematis dan menghasilkan solusi yang akurat dan dapat diandalkan untuk berbagai masalah matematika yang kompleks.

## Akurasi dan Presisi {#acuracy}

Perhatikan Gambar \@ref(fig:akurasi) berikut:

```{r akurasi,echo=FALSE, fig.cap='4 ilustrasi terkait akurasi dan presisi', tidy=FALSE, fig.align='center',out.width='75%', warning=FALSE}
library(knitr)
img1_path <- "./images/akurasi.png"
include_graphics(img1_path)

```

Pada Gambar \@ref(fig:akurasi) terdapat 4 buah kondisi ketika kita menembakkan beberapa perluru pada sebuah sasaran. Tujuan kita disini adalah untuk menembak bagian tengah sasaran tersebut.

Pada Gambar (a) dan (c) pada Gambar \@ref(fig:akurasi) merupakan gambar yang menunjukkan seseorang telah berhasil mengenai bagian tengah sasaran tersebut dapat kita katakan pula tembakan pada kedua gambar tersebut akurat. Akurat dalam hal ini dapat diartikan suatu kondisi dimana kedekatan lubang peluru dengan pusat sasaran. Secara umum akurasi diartikan sebagai tingkat kedekatan pengukuran kuantitas terhadap nilai sebenarnya.

Terdapat dua buah cara untuk mengukur akurasi. Metode pengukuran akurasi antara lain: error absolut dan error relatif. Error absolut merupakan nilai absolut dari selisih antara nilai sebenarnya $x$ dengan nilai observasi $x'$. Error absolut dapat dituliskan menggunakan Persamaan \@ref(eq:errorabsolut).

\begin{equation}
   \epsilon_A=\left|x-x'\right|
  (\#eq:errorabsolut)
\end{equation} 

Pengukuran lain yang sering digunakan untuk mengukur akurasi adalah error relatif. Berbeda dengan error absolut, error relatif membagi selisih antara nilai sebenarnya $x$ dan nilai observasi $x'$ dengan nilai sebenarnya. Hasil yang diperoleh merupakan nilai tanpa satuan. Persamaan error relatif disajikan pada Persamaan \@ref(eq:errorrelatif).

\begin{equation}
   \epsilon_R=\left|\frac{x-x'}{x}\right|
  (\#eq:errorrelatif)
\end{equation}

Dalam suatu pengukuran, hal lain yang perlu diperhatikan selain akurasi adalah presisi. Presisi adalah sejauh mana pengulangan pengukuran dalam kondisi yang tidak berubah mendapat hasil yang sama. Berdasarkan Gambar \@ref(fig:akurasi), Gambar (a) dan (b) menunjukkan kepresisian yang tinggi. Hal ini terlihat dari jarak antara lubang peluru yang saling berdekatan dan mengelompok.

Berdasarkan Gambar \@ref(fig:akurasi) dapat kita simpulkan bahwa dalam suatu sistem pengukuran akan terdapat 4 buah kondisi. Pengukuran akurat dan presisi (Gambar (a)), tidak akurat namun presisi (Gambar (b)), akurat namun tidak presisi (Gambar (c)), dan tidak akurat serta tidak presisi (Gambar (d)). Dalam analisa numerik error atau kesalahan menjadi hal yang perlu diperhatikan.

## Error Numerik 

Ketika kita menggunakan Metode Numerik untuk memecahkan masalah matematika, kita akan selalu dihadapkan pada konsep error numerik. Error numerik mengacu pada perbedaan antara solusi yang dihitung secara numerik dengan solusi yang sebenarnya atau solusi eksak dari masalah matematika tersebut. Karena kita menggunakan pendekatan angka-angka (numerik) daripada solusi eksak (analitis), error numerik merupakan hal yang tak terhindarkan. Terdapat beberapa jenis error numerik yang biasanya muncul dalam penerapan Metode Numerik, diperlihatkan pada subtopik berikut.

### Error Mutlak *(Absolute Error)* 

Ini adalah perbedaan absolut antara solusi yang dihitung secara numerik dan solusi eksak. Dinyatakan dalam satuan yang sama dengan solusi itu sendiri (misalnya, dalam angka atau satuan fisik tertentu). Misalkan Anda memiliki solusi eksak dari suatu masalah dan hasil yang dihitung secara numerik dalam bahasa pemrograman R. Anda dapat menghitung absolute error \@ref(eq:errorabsolut) sebagai perbedaan absolut antara solusi eksak dan hasil numerik.

```{r}
# Contoh solusi eksak
solusi_eksak <- 10.5

# Contoh hasil numerik
hasil_numerik <- 10.2

# Menghitung absolute error
absolute_error <- abs(solusi_eksak - hasil_numerik)

# Menampilkan hasil
print(paste("Absolute Error:", absolute_error))
```

### Error Relatif *(Relative Error)* 

Ini adalah perbandingan antara absolute error dengan solusi eksak. Dinyatakan sebagai persentase atau dalam bentuk pecahan, sehingga memberikan gambaran seberapa besar error dibandingkan dengan ukuran solusi. Untuk menghitung absolute error, dapat dilakukan seperti pada contoh sebelumnya. Kemudian, kita menghitung relative error \@ref(eq:errorrelatif) dengan membagi absolute error dengan nilai absolut dari solusi eksak, dan kemudian mengalikannya dengan 100 untuk mendapatkan persentase.

```{r}
# Contoh solusi eksak
solusi_eksak <- 10.5

# Contoh hasil numerik
hasil_numerik <- 10.2

# Menghitung absolute error
absolute_error <- abs(solusi_eksak - hasil_numerik)

# Menghitung relative error & konversi ke persentase
relative_error <- absolute_error / abs(solusi_eksak) * 100  

# Menampilkan hasil
print(paste("Relative Error:", relative_error, "%"))
```

### Truncation Error (Error Pemotongan)
Truncation error muncul ketika kita menggunakan pendekatan yang lebih sederhana atau mengabaikan suku-suku yang lebih kecil dalam perhitungan. Ini terutama terjadi dalam pendekatan deret tak hingga atau pendekatan iteratif yang menghentikan iterasi setelah jumlah langkah tertentu. Misalkan kita ingin menghitung nilai eksponensial menggunakan deret Taylor yang dipotong setelah beberapa suku:

```{r}
# Fungsi untuk menghitung nilai eksponensial menggunakan deret Taylor
exp_approx <- function(x, n) {
  approx_value <- 1  # Suku pertama dari deret
  for (i in 1:n) {
    approx_value <- approx_value + (x^i) / factorial(i)
  }
  return(approx_value)
}

# Nilai eksak dari e^2
exp_exact <- exp(2)

# Hitung nilai perkiraan eksponensial dengan deret Taylor (misal, n = 5)
n_terms <- 5
exp_approximation <- exp_approx(2, n_terms)

# Hitung truncation error
truncation_error <- abs(exp_exact - exp_approximation)

# Menampilkan hasil
print(paste("Truncation Error:", truncation_error))

```


### Error Pembulatan *(Round-off Error)*

Ini adalah kesalahan yang muncul karena keterbatasan representasi angka di komputer. Karena komputer hanya dapat merepresentasikan angka dalam bentuk biner (format floating-point), beberapa angka tidak dapat direpresentasikan secara tepat. Akibatnya, terdapat ketidakakuratan dalam perhitungan. Berikut adalah contoh sederhana menggunakan R:

```{r}
# Contoh perhitungan yang menghasilkan round-off error
result = 1.0 / 3.0 + 2.0 / 3.0

# Tampilkan hasil
print(result)

```


### Error Stabilitas *(Stability Error)*

Ketika sebuah metode numerik tidak stabil, hasil yang dihitung secara numerik bisa sangat sensitif terhadap perubahan kecil dalam input atau iterasi. Ini dapat menyebabkan perubahan besar dalam hasil yang diharapkan. Misalkan kita ingin mengilustrasikan error stabilitas dengan menggunakan metode numerik iteratif yang mengalami divergensi. Berikut adalah contoh sederhana:

```{r}
# Contoh metode iteratif yang mengalami divergensi
unstable_method <- function(x, n) {
  for (i in 1:n) {
    x <- 2 * x
  }
  return(x)
}

# Nilai awal
initial_value <- 0.1

# Hitung nilai setelah 10 iterasi
n_iterations <- 10
final_value <- unstable_method(initial_value, n_iterations)

# Tampilkan hasil
print(paste("Final Value after", n_iterations, "iterations:", final_value))
```

Untuk mengatasi error numerik, penting untuk memahami jenis error yang mungkin muncul dan mengambil langkah-langkah untuk meminimalkan dampaknya. Ini dapat melibatkan penggunaan metode yang lebih akurat, mengatur parameter iterasi dengan bijaksana, dan menggunakan teknik numerik yang tepat untuk masalah yang dihadapi. Selain itu, memahami tingkat akurasi yang diperlukan dalam konteks aplikasi juga penting untuk memutuskan apakah hasil numerik sudah cukup akurat atau tidak.

## Studi Kasus Error Numerik

### Ilustrasi Jenis error numerik

Berikut adalah contoh kasus sederhana yang mengilustrasikan beberapa jenis error numerik dalam bahasa pemrograman R:

```{r}
# Contoh kasus: Menghitung nilai akar kuadrat dari 2
nilai_eksak <- sqrt(2)  # Nilai akar kuadrat dari 2 sebenarnya

# Pendekatan numerik menggunakan deret Taylor (truncation error)
deret_taylor <- function(x, n) {
  approx_value <- 1
  for (i in 1:n) {
    approx_value <- approx_value + ((-1)^i * (x - 1)^i) / (i * factorial(i))
  }
  return(approx_value)
}

# Hitung nilai perkiraan akar kuadrat dari 2 dengan deret Taylor (misal, n = 5)
n_terms <- 5
nilai_approx_taylor <- deret_taylor(2, n_terms)

# Hitung absolute error
absolute_error_taylor <- abs(nilai_eksak - nilai_approx_taylor)

# Hitung relative error
relative_error_taylor <- absolute_error_taylor / abs(nilai_eksak) * 100

# Tampilkan hasil
print(paste("Nilai Akar Kuadrat dari 2 (Eksak):", nilai_eksak))
print(paste("Nilai Pendekatan Akar Kuadrat (Deret Taylor):", nilai_approx_taylor))
print(paste("Absolute Error (Deret Taylor):", absolute_error_taylor))
print(paste("Relative Error (Deret Taylor):", relative_error_taylor, "%"))
```

### Perhitungan Integral

Andaikan kita ingin melihat bagaimana error numerik dapat mempengaruhi perhitungan integral numerik dengan menggunakan metode kuadratur numerik. Kita akan mencoba menghitung integral dari fungsi $f(x)=x^2$ di rentang $[0, 2]$ menggunakan metode kuadratur numerik (misalnya, metode trapesium) dan membandingkannya dengan nilai eksak integral.

```{r}
# Fungsi untuk menghitung integral numerik dengan metode trapesium
integral_trapezoidal <- function(f, a, b, n) {
  h <- (b - a) / n
  sum <- 0.5 * (f(a) + f(b))
  for (i in 1:(n - 1)) {
    sum <- sum + f(a + i * h)
  }
  integral_approx <- h * sum
  return(integral_approx)
}

# Fungsi asli f(x) = x^3
f <- function(x) {
  return(x^3)
}

# Rentang integral [a, b]
a <- 0
b <- 2

# Nilai eksak integral dari f(x) = x^3
integral_exact <- (b^4) / 4

# Hitung nilai perkiraan integral dengan metode trapesium (misal, n = 4)
n_intervals <- 4
integral_approx <- integral_trapezoidal(f, a, b, n_intervals)

# Hitung absolute error
absolute_error <- abs(integral_exact - integral_approx)

# Hitung relative error
relative_error <- absolute_error / abs(integral_exact) * 100

# Tampilkan hasil
print(paste("Nilai Eksak Integral:", integral_exact))
print(paste("Nilai Perkiraan Integral (Metode Trapesium):", integral_approx))
print(paste("Absolute Error (Metode Trapesium):", absolute_error))
print(paste("Relative Error (Metode Trapesium):", relative_error, "%"))
```

Dalam contoh ini, kita mencoba menghitung integral dari fungsi $f(x)=x^2$ dengan rentang di rentang $[0, 2]$ menggunakan metode trapesium. Kita membandingkan hasil perkiraan integral dengan nilai eksak integral ${b^4 \over 4}$. Semakin banyak interval (nilai $n$) yang digunakan, semakin mendekati hasil perkiraan dengan nilai eksak, tetapi juga menghasilkan error numerik. Anda dapat mengubah nilai $n$ untuk melihat bagaimana error numerik berubah dengan peningkatan jumlah interval.

Mari lihat contoh kedua, gunakan fungsi sederhana $y = x^2$ di rentang $[0, 1]$

```{r}
# Fungsi yang ingin diintegrasikan: y = x^2
f <- function(x) {
  return(x^2)
}

# Batas integrasi
a <- 0  # Batas bawah
b <- 1  # Batas atas

# Jumlah partisi (subinterval)
n_partitions <- 1000

# Lebar setiap subinterval
dx <- (b - a) / n_partitions

# Hitung integral numerik dengan metode kuadratur numerik (Metode trapesium)
numerical_integral <- 0
for (i in 1:n_partitions) {
  x_left <- a + (i - 1) * dx
  x_right <- a + i * dx
  numerical_integral <- numerical_integral + (f(x_left) + f(x_right)) * dx / 2
}

# Integral sebenarnya (analitis)
actual_integral <- b^3 / 3 - a^3 / 3

# Hitung absolute error
absolute_error <- abs(actual_integral - numerical_integral)

# Hitung relative error
relative_error <- absolute_error / abs(actual_integral) * 100

# Tampilkan hasil
print(paste("Integral Numerik (Metode Trapesium):", numerical_integral))
print(paste("Integral Analitis:", actual_integral))
print(paste("Absolute Error:", absolute_error))
print(paste("Relative Error:", relative_error, "%"))
```

## Terapan Error Numerik 

Pada bagian ini diperlihatkan contoh penerapan metode error numerik dalam kehidupan sehari-hari.

### Studi Kasus Keuangan

Salah satu contoh studi kasus error numerik dalam keuangan adalah ketika melakukan perhitungan pada instrumen keuangan yang memiliki tingkat bunga yang sangat rendah atau sangat tinggi. Perhitungan yang melibatkan tingkat bunga rendah atau tinggi dapat menyebabkan error numerik karena keterbatasan representasi angka di komputer.

Misalkan kita ingin menghitung nilai masa depan (future value) dari suatu investasi dengan tingkat bunga yang sangat rendah atau sangat tinggi. Kita akan menggunakan rumus future value sebagai berikut:

$$FV=PV×(1+r)^n$$
 

Di mana:

* $FV$ adalah nilai masa depan investasi.
* $PV$ adalah nilai saat ini investasi.
* $r$ adalah tingkat bunga (dalam bentuk desimal).
* $n$ adalah jumlah periode.

Ketika $r$ sangat kecil (misalnya, mendekati 0), atau $r$ sangat besar, perhitungan nilai $(1+r)^n$  bisa menjadi masalah. Tingkat bunga yang sangat rendah atau tinggi dapat menghasilkan nilai $(1+r)^n$ yang sangat dekat dengan 1 atau nilai yang sangat besar, yang dapat menyebabkan error pembulatan atau overflow dalam komputasi.

Contoh implementasi dalam R:

```{r}
# Contoh perhitungan Future Value dengan tingkat bunga rendah dan tinggi
PV <- 1000  # Nilai saat ini investasi
n <- 10     # Jumlah periode

# Tingkat bunga rendah dan tinggi
r_low <- 0.0001
r_high <- 100

# Hitung Future Value
FV_low <- PV * (1 + r_low)^n
FV_high <- PV * (1 + r_high)^n

# Tampilkan hasil
print(paste("Future Value (Low Interest Rate):", FV_low))
print(paste("Future Value (High Interest Rate):", FV_high))
```

Dalam kasus ini, perhatikan bagaimana tingkat bunga rendah (r_low) menghasilkan hasil yang sangat mendekati nilai awal investasi. Di sisi lain, tingkat bunga yang sangat tinggi (r_high) menghasilkan nilai yang sangat besar dan mungkin menyebabkan overflow atau masalah numerik lainnya. Studi kasus ini menunjukkan pentingnya memperhatikan keterbatasan representasi angka di komputer saat melakukan perhitungan keuangan, terutama dengan angka yang sangat kecil atau sangat besar.

###  Jumlah Sampel

Mari kita lihat contoh studi kasus yang melibatkan error numerik dalam jumlah sampel dalam bahasa R. Kita akan menggunakan pendekatan Monte Carlo untuk memperkirakan nilai $π$ (pi).

Pendekatan Monte Carlo adalah salah satu metode numerik yang mengandalkan pembangkitan angka acak untuk memperkirakan solusi numerik. Dalam hal ini, kita akan menggunakan pendekatan ini untuk memperkirakan nilai π dengan menghasilkan titik-titik acak di dalam sebuah lingkaran dan menghitung berapa banyak di antaranya jatuh di dalam lingkaran.

```{r}
# Jumlah total titik yang akan digunakan
total_points <- 1000000

# Fungsi untuk menghitung estimasi nilai π
monte_carlo_pi <- function(total_points) {
  points_inside_circle <- 0
  for (i in 1:total_points) {
    x <- runif(1, min = -1, max = 1)
    y <- runif(1, min = -1, max = 1)
    if (x^2 + y^2 <= 1) {
      points_inside_circle <- points_inside_circle + 1
    }
  }
  estimated_pi <- 4 * points_inside_circle / total_points
  return(estimated_pi)
}

# Hitung estimasi nilai π
estimated_pi <- monte_carlo_pi(total_points)

# Tampilkan hasil
print(paste("Estimasi Nilai π dengan", total_points, "titik:", estimated_pi))
print(paste("Error absolut:", abs(estimated_pi - pi)))
print(paste("Error relatif:", abs(estimated_pi - pi) / pi * 100, "%"))

```

Dalam contoh ini, kita menggunakan pendekatan Monte Carlo untuk memperkirakan nilai $π$ dengan menghasilkan titik-titik acak di dalam lingkaran dengan radius 1 dan menghitung berapa banyak dari titik-titik ini jatuh di dalam lingkaran tersebut. Semakin banyak titik yang kita gunakan, semakin akurat perkiraan kita. Anda dapat mengubah nilai `total_points` untuk melihat bagaimana error numerik berubah dengan jumlah sampel yang berbeda. 

Perhatikan bahwa dalam kasus ini, error numerik terkait dengan pendekatan Monte Carlo dan jumlah sampel yang digunakan. Semakin banyak sampel yang digunakan, semakin mendekati perkiraan kita dengan nilai $π$ yang sebenarnya.


### Jumlah Iterasi

Mari kita lihat contoh studi kasus yang menggambarkan bagaimana error numerik dapat berkembang seiring dengan jumlah iterasi dalam sebuah metode numerik. Kita akan menggunakan metode iteratif untuk menghitung akar kuadrat dari 2 dan melihat bagaimana error berkembang seiring dengan meningkatnya jumlah iterasi.

```{r}
# Nilai eksak akar kuadrat dari 2
nilai_eksak <- sqrt(2)

# Metode iteratif untuk menghitung akar kuadrat
iterative_method <- function(x, n) {
  approx_value <- x
  for (i in 1:n) {
    approx_value <- 0.5 * (approx_value + x / approx_value)
  }
  return(approx_value)
}

# Jumlah iterasi yang akan diuji
jumlah_iterasi <- c(1, 2, 5, 10, 20, 50, 100, 200)

# Hitung nilai perkiraan akar kuadrat dari 2 dengan jumlah iterasi yang berbeda
nilai_approximations <- sapply(jumlah_iterasi, function(iter) iterative_method(2, iter))

# Hitung absolute error untuk setiap iterasi
absolute_errors <- abs(nilai_eksak - nilai_approximations)

# Tampilkan hasil
results <- data.frame(Jumlah_Iterasi = jumlah_iterasi, Perkiraan_Akar = nilai_approximations, Absolute_Error = absolute_errors)
print(results)

```

Dalam contoh ini, kita menggunakan metode Newton-Raphson iteratif untuk menghitung akar kuadrat dari 2. Kami menghitung perkiraan akar kuadrat untuk berbagai jumlah iterasi yang berbeda dan mengukur absolute error antara nilai perkiraan dan nilai eksak. Dengan melihat hasilnya, Anda dapat melihat bagaimana error numerik berkurang seiring dengan peningkatan jumlah iterasi. Semakin banyak iterasi, semakin mendekati hasil numerik dengan nilai eksak.

Anda dapat memodifikasi jumlah_iterasi sesuai dengan preferensi Anda untuk melihat bagaimana error numerik berkembang dengan lebih banyak iterasi. Ingatlah bahwa, meskipun error numerik berkurang seiring dengan peningkatan jumlah iterasi, ada batasan akurasi yang dicapai karena keterbatasan representasi angka di komputer.

## Referensi

1. Howard, J.P. 2017. **Computational Methods for Numerical Analysis with R**. CRC Press.
2. Sutarno,H., Rachmatin,D. 2008. **Hands Out Metode Numerik**. Universitas Pendidikan Indonesia.


